// ============================================
// NHL API INTEGRATION with OCTOBER 2025 FALLBACK
// Last Hardcoded Roster Date: October 31, 2025
// ============================================

let rosterData = [];
let questions = [];
let allQuestions = [];
let rosterSource = 'loading...';
let rosterTimestamp = '';

// FALLBACK ROSTER - October 31, 2025 VGK Active Roster
const FALLBACK_ROSTER_DATE = "October 31, 2025";
const FALLBACK_ROSTER = [
    // GOALIES (3)
    { firstName: {default: 'Adin'}, lastName: {default: 'Hill'}, sweaterNumber: 33, shootsCatches: 'L', position: 'G', positionGroup: 'goalies' },
    { firstName: {default: 'Carl'}, lastName: {default: 'Lindbom'}, sweaterNumber: 30, shootsCatches: 'L', position: 'G', positionGroup: 'goalies' },
    { firstName: {default: 'Akira'}, lastName: {default: 'Schmid'}, sweaterNumber: 40, shootsCatches: 'L', position: 'G', positionGroup: 'goalies' },
    
    // DEFENSE (7)
    { firstName: {default: 'Zach'}, lastName: {default: 'Whitecloud'}, sweaterNumber: 2, shootsCatches: 'R', position: 'D', positionGroup: 'defense' },
    { firstName: {default: 'Brayden'}, lastName: {default: 'McNabb'}, sweaterNumber: 3, shootsCatches: 'L', position: 'D', positionGroup: 'defense' },
    { firstName: {default: 'Jeremy'}, lastName: {default: 'Lauzon'}, sweaterNumber: 5, shootsCatches: 'L', position: 'D', positionGroup: 'defense' },
    { firstName: {default: 'Kaedan'}, lastName: {default: 'Korczak'}, sweaterNumber: 6, shootsCatches: 'R', position: 'D', positionGroup: 'defense' },
    { firstName: {default: 'Noah'}, lastName: {default: 'Hanifin'}, sweaterNumber: 15, shootsCatches: 'L', position: 'D', positionGroup: 'defense' },
    { firstName: {default: 'Ben'}, lastName: {default: 'Hutton'}, sweaterNumber: 17, shootsCatches: 'L', position: 'D', positionGroup: 'defense' },
    { firstName: {default: 'Shea'}, lastName: {default: 'Theodore'}, sweaterNumber: 27, shootsCatches: 'L', position: 'D', positionGroup: 'defense' },
    
    // FORWARDS - Centers (5)
    { firstName: {default: 'Jack'}, lastName: {default: 'Eichel'}, sweaterNumber: 9, shootsCatches: 'R', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'Colton'}, lastName: {default: 'Sissons'}, sweaterNumber: 10, shootsCatches: 'R', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'Brett'}, lastName: {default: 'Howden'}, sweaterNumber: 21, shootsCatches: 'L', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'Tomas'}, lastName: {default: 'Hertl'}, sweaterNumber: 48, shootsCatches: 'L', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'William'}, lastName: {default: 'Karlsson'}, sweaterNumber: 71, shootsCatches: 'L', position: 'F', positionGroup: 'forwards' },
    
    // FORWARDS - Wings (8)
    { firstName: {default: 'Pavel'}, lastName: {default: 'Dorofeyev'}, sweaterNumber: 16, shootsCatches: 'L', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'Reilly'}, lastName: {default: 'Smith'}, sweaterNumber: 19, shootsCatches: 'L', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'Brandon'}, lastName: {default: 'Saad'}, sweaterNumber: 20, shootsCatches: 'L', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'Cole'}, lastName: {default: 'Reinhardt'}, sweaterNumber: 23, shootsCatches: 'L', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'Alexander'}, lastName: {default: 'Holtz'}, sweaterNumber: 26, shootsCatches: 'R', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'Ivan'}, lastName: {default: 'Barbashev'}, sweaterNumber: 49, shootsCatches: 'L', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'Keegan'}, lastName: {default: 'Kolesar'}, sweaterNumber: 55, shootsCatches: 'R', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'Mark'}, lastName: {default: 'Stone'}, sweaterNumber: 61, shootsCatches: 'R', position: 'F', positionGroup: 'forwards' },
    { firstName: {default: 'Mitch'}, lastName: {default: 'Marner'}, sweaterNumber: 93, shootsCatches: 'R', position: 'F', positionGroup: 'forwards' }
];

// Fetch VGK roster from NHL API
async function fetchVGKRoster() {
    try {
        console.log('üîÑ Fetching live roster from NHL API...');
        const response = await fetch('https://api-web.nhle.com/v1/roster/VGK/current');
        
        if (!response.ok) {
            throw new Error(`API returned ${response.status}`);
        }
        
        const data = await response.json();
        
        // Parse roster data
        rosterData = [
            ...data.forwards.map(p => ({ ...p, position: 'F', positionGroup: 'forwards' })),
            ...data.defensemen.map(p => ({ ...p, position: 'D', positionGroup: 'defense' })),
            ...data.goalies.map(p => ({ ...p, position: 'G', positionGroup: 'goalies' }))
        ];
        
        rosterSource = 'Live NHL API';
        rosterTimestamp = new Date().toLocaleString();
        
        console.log('‚úÖ Successfully fetched live roster:', rosterData.length, 'players');
        return rosterData;
    } catch (error) {
        console.error('‚ùå API Error:', error.message);
        console.log('‚ö†Ô∏è  Using fallback roster from', FALLBACK_ROSTER_DATE);
        return useFallbackRoster();
    }
}

function useFallbackRoster() {
    rosterSource = `Hardcoded Fallback (${FALLBACK_ROSTER_DATE})`;
    rosterTimestamp = FALLBACK_ROSTER_DATE;
    return FALLBACK_ROSTER;
}

// Generate questions dynamically from roster data
function generateQuestions(roster) {
    const generatedQuestions = [];
    
    roster.forEach(player => {
        const firstName = player.firstName?.default || '';
        const lastName = player.lastName?.default || '';
        const fullName = `${firstName} ${lastName}`;
        const number = player.sweaterNumber;
        const shoots = player.shootsCatches;
        const position = player.position;
        const posGroup = player.positionGroup;
        
        // Get other players for wrong answers
        const otherPlayers = roster.filter(p => p.sweaterNumber !== number);
        const randomOther = () => otherPlayers[Math.floor(Math.random() * otherPlayers.length)];
        
        // Number questions
        generatedQuestions.push({
            q: `What # does ${firstName} ${lastName} wear?`,
            correct: String(number),
            wrong: String(randomOther()?.sweaterNumber || number + 1),
            cat: ["numbers", posGroup]
        });
        
        generatedQuestions.push({
            q: `Who wears #${number}?`,
            correct: fullName,
            wrong: `${randomOther()?.firstName?.default} ${randomOther()?.lastName?.default}`,
            cat: ["numbers", posGroup]
        });
        
        generatedQuestions.push({
            q: `${lastName}'s number?`,
            correct: String(number),
            wrong: String(randomOther()?.sweaterNumber || number + 1),
            cat: ["numbers", posGroup]
        });
        
        generatedQuestions.push({
            q: `Who is #${number}?`,
            correct: lastName,
            wrong: randomOther()?.lastName?.default || 'Smith',
            cat: ["numbers", posGroup]
        });
        
        // Handedness questions
        const handText = position === 'G' ? 'catch with' : 'shoot';
        const handLong = shoots === 'L' ? 'Left' : 'Right';
        const handWrong = shoots === 'L' ? 'Right' : 'Left';
        
        generatedQuestions.push({
            q: `Which hand does ${lastName} ${handText}?`,
            correct: handLong,
            wrong: handWrong,
            cat: ["handedness", posGroup]
        });
        
        generatedQuestions.push({
            q: `Which side does ${firstName} ${lastName} ${handText}?`,
            correct: handLong,
            wrong: handWrong,
            cat: ["handedness", posGroup]
        });
        
        // Position questions
        generatedQuestions.push({
            q: `What position does ${firstName} ${lastName} play?`,
            correct: position,
            wrong: position === 'F' ? 'D' : position === 'D' ? 'F' : 'D',
            cat: ["position", posGroup]
        });
        
        generatedQuestions.push({
            q: `What position is ${lastName}?`,
            correct: position,
            wrong: position === 'F' ? 'D' : position === 'D' ? 'G' : 'F',
            cat: ["position", posGroup]
        });
    });
    
    // Add aggregate questions
    const forwards = roster.filter(p => p.positionGroup === 'forwards');
    const defense = roster.filter(p => p.positionGroup === 'defense');
    const goalies = roster.filter(p => p.positionGroup === 'goalies');
    
    generatedQuestions.push({
        q: "How many goalies are on the roster?",
        correct: String(goalies.length),
        wrong: String(goalies.length + 1),
        cat: ["position", "goalies"]
    });
    
    generatedQuestions.push({
        q: "How many defensemen are on the roster?",
        correct: String(defense.length),
        wrong: String(defense.length - 1),
        cat: ["position", "defense"]
    });
    
    generatedQuestions.push({
        q: "How many forwards are on the roster?",
        correct: String(forwards.length),
        wrong: String(forwards.length - 1),
        cat: ["position", "forwards"]
    });
    
    // Handedness counts
    const goalieCatchLeft = goalies.filter(p => p.shootsCatches === 'L').length;
    const defenseShotsRight = defense.filter(p => p.shootsCatches === 'R').length;
    const defenseShotsLeft = defense.filter(p => p.shootsCatches === 'L').length;
    
    if (goalieCatchLeft === goalies.length) {
        generatedQuestions.push({
            q: "Which hand do all goalies catch with?",
            correct: "Left",
            wrong: "Right",
            cat: ["handedness", "goalies"]
        });
    }
    
    generatedQuestions.push({
        q: "How many defensemen shoot right?",
        correct: String(defenseShotsRight),
        wrong: String(defenseShotsRight + 1),
        cat: ["handedness", "defense"]
    });
    
    generatedQuestions.push({
        q: "How many defensemen shoot left?",
        correct: String(defenseShotsLeft),
        wrong: String(defenseShotsLeft - 1),
        cat: ["handedness", "defense"]
    });
    
    console.log('‚úÖ Generated', generatedQuestions.length, 'questions');
    return generatedQuestions;
}

// Initialize app
async function initializeApp() {
    console.log('üèí Initializing VGK Roster Quiz...');
    const roster = await fetchVGKRoster();
    questions = generateQuestions(roster);
    allQuestions = questions;
    
    // Update timestamp display
    updateTimestampDisplay();
    
    console.log('‚úÖ Quiz ready with', questions.length, 'questions');
    console.log('üìä Roster source:', rosterSource);
}

// Update timestamp in UI
function updateTimestampDisplay() {
    const timestampDiv = document.getElementById('rosterTimestamp');
    if (timestampDiv) {
        timestampDiv.innerHTML = `
            <div style="text-align: center; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-bottom: 15px; font-size: 13px;">
                <strong style="color: var(--h3-color);">Roster Source:</strong> ${rosterSource}<br>
                <strong style="color: var(--h3-color);">Last Updated:</strong> ${rosterTimestamp}
            </div>
        `;
    }
}

// Initialize on load
initializeApp();

// ============================================
// QUIZ LOGIC (unchanged from original)
// ============================================

let shuffledQuestions = [];
let userAnswers = {};
let questionStats = {};

function loadStats() {
    const saved = localStorage.getItem('rosterQuizStats');
    if (saved) {
        questionStats = JSON.parse(saved);
    }
}

function saveStats() {
    localStorage.setItem('rosterQuizStats', JSON.stringify(questionStats));
}

function resetStats() {
    if (confirm('Are you sure you want to reset all your quiz statistics? This cannot be undone.')) {
        questionStats = {};
        localStorage.removeItem('rosterQuizStats');
        alert('‚úì All statistics have been reset!');
        location.reload();
    }
}

function loadPalette() {
    const saved = localStorage.getItem('colorPalette');
    if (saved) {
        document.body.className = saved === 'bold' ? 'palette-bold' : '';
        document.getElementById(`palette-${saved}`).checked = true;
    }
}

function savePalette(palette) {
    localStorage.setItem('colorPalette', palette);
}

function selectPalette(palette) {
    document.getElementById(`palette-${palette}`).checked = true;
    document.body.className = palette === 'bold' ? 'palette-bold' : '';
    savePalette(palette);
}

function toggleCategory(catId) {
    const checkbox = document.getElementById(`cat-${catId}`);
    checkbox.checked = !checkbox.checked;
    updateStartButton();
}

function updateStartButton() {
    const anyChecked = Array.from(document.querySelectorAll('.category-selection input[type="checkbox"]'))
        .some(cb => cb.checked);
    document.getElementById('startBtn').disabled = !anyChecked;
}

function getSelectedCategories() {
    return Array.from(document.querySelectorAll('.category-selection input[type="checkbox"]:checked'))
        .map(cb => cb.id.replace('cat-', ''));
}

function startQuiz() {
    const selected = getSelectedCategories();
    if (selected.length === 0) {
        alert('Please select at least one category!');
        return;
    }

    const filtered = allQuestions.filter(q => 
        q.cat.some(c => selected.includes(c))
    );

    if (filtered.length === 0) {
        alert('No questions available for selected categories!');
        return;
    }

    shuffledQuestions = shuffleWithPriority(filtered);
    userAnswers = {};

    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('quizScreen').style.display = 'block';
    document.getElementById('score').style.display = 'none';

    renderQuestions();
}

function shuffleWithPriority(arr) {
    const incorrect = [];
    const correct = [];
    const unanswered = [];

    arr.forEach(q => {
        const stat = questionStats[q.q];
        if (!stat) {
            unanswered.push(q);
        } else if (stat.lastResult === 'incorrect') {
            incorrect.push(q);
        } else {
            correct.push(q);
        }
    });

    const shuffleArray = (a) => {
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
    };

    return [
        ...shuffleArray(incorrect),
        ...shuffleArray(unanswered),
        ...shuffleArray(correct)
    ];
}

function renderQuestions() {
    const container = document.getElementById('questions');
    container.innerHTML = '';

    shuffledQuestions.forEach((item, index) => {
        const questionDiv = document.createElement('div');
        questionDiv.className = 'question';

        let statusBadge = '';
        const stat = questionStats[item.q];
        if (stat?.lastResult === 'incorrect') {
            statusBadge = '<span class="status-badge status-wrong">MISSED LAST TIME</span>';
        } else if (stat?.lastResult === 'correct') {
            statusBadge = '<span class="status-badge status-correct">GOT IT LAST TIME</span>';
        }

        const options = [item.correct, item.wrong].sort(() => Math.random() - 0.5);

        questionDiv.innerHTML = `
            <div class="question-text">${index + 1}. ${item.q} ${statusBadge}</div>
            <div class="options">
                ${options.map(opt => `
                    <button type="button" class="option-btn" data-question="${index}" onclick="selectAnswer(${index}, '${opt.replace(/'/g, "\\'")}', '${item.correct.replace(/'/g, "\\'")}')">${opt}</button>
                `).join('')}
            </div>
            <div class="feedback" id="f${index}"></div>
        `;

        container.appendChild(questionDiv);
    });

    updateProgress();
}

function selectAnswer(questionIndex, selectedAnswer, correctAnswer) {
    const buttons = document.querySelectorAll(`[data-question="${questionIndex}"]`);
    
    buttons.forEach(btn => {
        btn.classList.remove('selected');
        if (btn.textContent === selectedAnswer) {
            btn.classList.add('selected');
        }
    });

    userAnswers[questionIndex] = (selectedAnswer === correctAnswer);
    updateProgress();
}

function updateProgress() {
    const answered = Object.keys(userAnswers).length;
    const total = shuffledQuestions.length;
    document.getElementById('progress').textContent = 
        `Answered: ${answered}/${total} ‚Ä¢ Select answers then click Submit`;
}

function backToStart() {
    document.getElementById('startScreen').style.display = 'block';
    document.getElementById('quizScreen').style.display = 'none';
}

function shuffleQuiz() {
    if (confirm('Shuffle the quiz? This will reset your current answers.')) {
        startQuiz();
    }
}

function exportStats() {
    const dataStr = JSON.stringify(questionStats, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'roster-quiz-stats.json';
    a.click();
    URL.revokeObjectURL(url);
}

function viewStats() {
    const totalQuestions = allQuestions.length;
    const answeredQuestions = Object.keys(questionStats).length;
    const unanswered = totalQuestions - answeredQuestions;

    let correct = 0;
    let incorrect = 0;
    let totalCorrect = 0;
    let totalIncorrect = 0;

    Object.values(questionStats).forEach(stat => {
        if (stat.lastResult === 'correct') correct++;
        if (stat.lastResult === 'incorrect') incorrect++;
        totalCorrect += stat.correct || 0;
        totalIncorrect += stat.incorrect || 0;
    });

    const totalAttempts = totalCorrect + totalIncorrect;
    const accuracy = totalAttempts > 0 ? Math.round((totalCorrect / totalAttempts) * 100) : 0;

    const statsMessage = `
üìä ROSTER QUIZ STATISTICS

Overall Performance:
‚Ä¢ Total Questions: ${totalQuestions}
‚Ä¢ Questions Attempted: ${answeredQuestions}
‚Ä¢ Not Yet Attempted: ${unanswered}

Current Status:
‚Ä¢ Last Answered Correctly: ${correct}
‚Ä¢ Last Answered Incorrectly: ${incorrect}
‚Ä¢ Unanswered: ${unanswered}

All-Time Accuracy:
‚Ä¢ Total Attempts: ${totalAttempts}
‚Ä¢ Correct Answers: ${totalCorrect}
‚Ä¢ Incorrect Answers: ${totalIncorrect}
‚Ä¢ Accuracy Rate: ${accuracy}%

Questions you got wrong will appear first when you shuffle the quiz!
    `.trim();

    alert(statsMessage);
}

loadStats();
loadPalette();
updateStartButton();

document.getElementById('quizForm').addEventListener('submit', function(e) {
    e.preventDefault();

    let correct = 0;
    let total = shuffledQuestions.length;

    shuffledQuestions.forEach((item, index) => {
        const buttons = document.querySelectorAll(`[data-question="${index}"]`);
        const feedback = document.getElementById(`f${index}`);
        const userAnswer = userAnswers[index];

        if (!questionStats[item.q]) {
            questionStats[item.q] = { correct: 0, incorrect: 0 };
        }

        if (userAnswer === true) {
            correct++;
            questionStats[item.q].correct++;
            questionStats[item.q].lastResult = 'correct';
            feedback.className = 'feedback correct';
            feedback.textContent = '‚úì Correct!';
            feedback.style.display = 'block';

            buttons.forEach(btn => {
                if (btn.textContent === item.correct) {
                    btn.classList.add('correct');
                }
            });
        } else if (userAnswer === false) {
            questionStats[item.q].incorrect++;
            questionStats[item.q].lastResult = 'incorrect';
            feedback.className = 'feedback incorrect';
            feedback.textContent = `‚úó Correct answer: ${item.correct}`;
            feedback.style.display = 'block';

            buttons.forEach(btn => {
                if (btn.textContent === item.correct) {
                    btn.classList.add('correct');
                } else {
                    btn.classList.add('incorrect');
                }
            });
        } else {
            feedback.className = 'feedback incorrect';
            feedback.textContent = `‚ö† Not answered. Correct: ${item.correct}`;
            feedback.style.display = 'block';

            buttons.forEach(btn => {
                if (btn.textContent === item.correct) {
                    btn.classList.add('correct');
                }
            });
        }
    });

    const scoreDiv = document.getElementById('score');
    const percentage = Math.round((correct / total) * 100);
    scoreDiv.textContent = `Score: ${correct}/${total} (${percentage}%)`;
    scoreDiv.style.display = 'block';

    saveStats();
    window.scrollTo({ top: 0, behavior: 'smooth' });
});